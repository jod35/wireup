{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WireUp Dependency and configuration injection library in Python. 1. Set application configuration parameters container.params.update({ \"db.connection_str\": \"sqlite://memory\", \"auth.user\": os.environ.get(\"USER\"), \"cache_dir\": \"/var/cache/\", \"env\": os.environ.get(\"ENV\", \"dev\") }) 2. Register dependencies @container.register class DbService: def __init__( self, # Inject a parameter by name connection_str: str = wire(param=\"db.connection_str\"), # Or by interpolating multiple parameters into a string cache_dir: str = wire(expr=\"${cache_dir}/${auth.user}/db\"), ): self.connection_str = connection_str self.cache_dir = cache_dir # Constructor injection is also supported for dataclasses # resulting in a more compact syntax. @container.register @dataclass class UserRepository: db: DbService # Dependencies may also depend on other dependencies. user: str = container.wire(param=\"auth.user\") 3. Inject # Decorate all methods where the library must perform injection. @app.route(\"/greet/<str:name>\") @container.autowire # Classes are automatically injected based on annotated type. # Parameters will be located based on the hint given in their default value. # Unknown arguments will not be processed. def greet(name: str, user_repository: UserRepository, env: str = wire(param=\"env\")): ... Installation # Install using poetry: poetry add wireup # Install using pip: pip install wireup","title":"Home"},{"location":"#wireup","text":"Dependency and configuration injection library in Python. 1. Set application configuration parameters container.params.update({ \"db.connection_str\": \"sqlite://memory\", \"auth.user\": os.environ.get(\"USER\"), \"cache_dir\": \"/var/cache/\", \"env\": os.environ.get(\"ENV\", \"dev\") }) 2. Register dependencies @container.register class DbService: def __init__( self, # Inject a parameter by name connection_str: str = wire(param=\"db.connection_str\"), # Or by interpolating multiple parameters into a string cache_dir: str = wire(expr=\"${cache_dir}/${auth.user}/db\"), ): self.connection_str = connection_str self.cache_dir = cache_dir # Constructor injection is also supported for dataclasses # resulting in a more compact syntax. @container.register @dataclass class UserRepository: db: DbService # Dependencies may also depend on other dependencies. user: str = container.wire(param=\"auth.user\") 3. Inject # Decorate all methods where the library must perform injection. @app.route(\"/greet/<str:name>\") @container.autowire # Classes are automatically injected based on annotated type. # Parameters will be located based on the hint given in their default value. # Unknown arguments will not be processed. def greet(name: str, user_repository: UserRepository, env: str = wire(param=\"env\")): ... Installation # Install using poetry: poetry add wireup # Install using pip: pip install wireup","title":"WireUp"},{"location":"interfaces/","text":"Working with Interfaces When autowiring dependencies, you might want to inject an interface rather than the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class that's marked as abstract within the container. The following code registers Engine as an interface. This implies that Engine can't be directly injected. Instead, a dependency that implements the interface must be present and also be registered in the container. @container.abstract class Engine: def do_thing(self): ... To autowire interfaces, you can simply register a dependency that implements the interface within the container. When injecting, ask for the interface itself, not its concrete implementation. @container.register class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" @container.autowire def do_engine_things(engine: Engine): return engine.do_thing() # Returns \"I'm a Combustion Engine\" In scenarios where there are multiple implementations of an interface, each implementation must be associated with a qualifier. @container.register(qualifier=\"electric\") class ElectricEngine(Engine): def do_thing(self): return \"I'm an Electric Engine\" @container.register(qualifier=\"combustion\") class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" While injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate which concrete class should be resolved. def home( engine: Engine = wire(qualifier=\"electric\"), combustion: Engine = wire(qualifier=\"combustion\"), ): ...","title":"Working with Interfaces"},{"location":"interfaces/#working-with-interfaces","text":"When autowiring dependencies, you might want to inject an interface rather than the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class that's marked as abstract within the container. The following code registers Engine as an interface. This implies that Engine can't be directly injected. Instead, a dependency that implements the interface must be present and also be registered in the container. @container.abstract class Engine: def do_thing(self): ... To autowire interfaces, you can simply register a dependency that implements the interface within the container. When injecting, ask for the interface itself, not its concrete implementation. @container.register class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" @container.autowire def do_engine_things(engine: Engine): return engine.do_thing() # Returns \"I'm a Combustion Engine\" In scenarios where there are multiple implementations of an interface, each implementation must be associated with a qualifier. @container.register(qualifier=\"electric\") class ElectricEngine(Engine): def do_thing(self): return \"I'm an Electric Engine\" @container.register(qualifier=\"combustion\") class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" While injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate which concrete class should be resolved. def home( engine: Engine = wire(qualifier=\"electric\"), combustion: Engine = wire(qualifier=\"combustion\"), ): ...","title":"Working with Interfaces"},{"location":"introduction/","text":"Introduction WireUp is a Python library designed to provide a powerful and flexible way to manage and inject dependencies across your application, making it easier to develop, test, and maintain your codebase. Key features include: Dependency Injection: Effortlessly inject dependencies into your classes and functions using a clean and intuitive syntax. Lazy loading: Dependencies injected by the library are lazily loaded and will be only initialized on first use. Singleton dependencies: Every dependency is initialized only once and all references to it will reuse the same instance. Parameter Management: Manage your application's parameters and configuration values supporting parameter interpolation and referencing. Async ready: The library supports autowiring on async methods Framework Integration: Seamlessly integrate with popular web frameworks like FastAPI and Flask to simplify dependency management in web applications. Service Locator: You can use the container to retrieve classes by their type for more advanced use cases.","title":"Introduction"},{"location":"introduction/#introduction","text":"WireUp is a Python library designed to provide a powerful and flexible way to manage and inject dependencies across your application, making it easier to develop, test, and maintain your codebase. Key features include: Dependency Injection: Effortlessly inject dependencies into your classes and functions using a clean and intuitive syntax. Lazy loading: Dependencies injected by the library are lazily loaded and will be only initialized on first use. Singleton dependencies: Every dependency is initialized only once and all references to it will reuse the same instance. Parameter Management: Manage your application's parameters and configuration values supporting parameter interpolation and referencing. Async ready: The library supports autowiring on async methods Framework Integration: Seamlessly integrate with popular web frameworks like FastAPI and Flask to simplify dependency management in web applications. Service Locator: You can use the container to retrieve classes by their type for more advanced use cases.","title":"Introduction"},{"location":"manual_configuration/","text":"Manual Configuration WireUp provides convenient decorators and functions for you to use and perform dependency injection. If using decorators or functions such as wire not appropriate for your application then manual container configuration is also possible. Using wireup without registration decorators In addition to using @container.register to register each dependency, automatic registration is also possible by using the container.regiter_all_in_module(module, pattern = \"*\") method. Module represents the top level module containing all your dependencies, optionally a fnmatch pattern can be specified to only register classes that match the pattern. This is the equivalent of using @container.register on each. container.register_all_in_module(app.service, \"*Service\") Manually wiring parameters Given that parameters can't be resolved from type annotations alone, the container.wire method offers two shortcuts for parameter injection: wire(name=\"\") and wire(expr=\"\") . To achieve the same outcome without relying on default values, you can use the container's initialization context. This allows you to manually provide data that the library would otherwise gather from the decorators. container.register_all_in_module(app.services, \"*Service\") # Register parameters individually using add_param container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=\"connection_str\", ) container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=TemplatedString(\"${cache_dir}/${auth_user}/db\"), ) # Alternatively, you can update the context in bulk using a dictionary of initializer parameter names as keys # and container parameter references as values. # When using interpolated strings, make sure you wrap the string with TemplatedString. container.initialization_context.update( DbService, { \"connection_str\": \"connection_str\", \"cache_dir\": TemplatedString(\"${cache_dir}/${USER}/db\"), }, ) Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.","title":"Manual configuration"},{"location":"manual_configuration/#manual-configuration","text":"WireUp provides convenient decorators and functions for you to use and perform dependency injection. If using decorators or functions such as wire not appropriate for your application then manual container configuration is also possible.","title":"Manual Configuration"},{"location":"manual_configuration/#using-wireup-without-registration-decorators","text":"In addition to using @container.register to register each dependency, automatic registration is also possible by using the container.regiter_all_in_module(module, pattern = \"*\") method. Module represents the top level module containing all your dependencies, optionally a fnmatch pattern can be specified to only register classes that match the pattern. This is the equivalent of using @container.register on each. container.register_all_in_module(app.service, \"*Service\")","title":"Using wireup without registration decorators"},{"location":"manual_configuration/#manually-wiring-parameters","text":"Given that parameters can't be resolved from type annotations alone, the container.wire method offers two shortcuts for parameter injection: wire(name=\"\") and wire(expr=\"\") . To achieve the same outcome without relying on default values, you can use the container's initialization context. This allows you to manually provide data that the library would otherwise gather from the decorators. container.register_all_in_module(app.services, \"*Service\") # Register parameters individually using add_param container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=\"connection_str\", ) container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=TemplatedString(\"${cache_dir}/${auth_user}/db\"), ) # Alternatively, you can update the context in bulk using a dictionary of initializer parameter names as keys # and container parameter references as values. # When using interpolated strings, make sure you wrap the string with TemplatedString. container.initialization_context.update( DbService, { \"connection_str\": \"connection_str\", \"cache_dir\": TemplatedString(\"${cache_dir}/${USER}/db\"), }, ) Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.","title":"Manually wiring parameters"},{"location":"multiple_containers/","text":"Multiple Containers As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers. The default wireup.container is simply an instance just like any other. If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators. To wire parameters use initialization context or the wire method. The wire method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire. Use of @autowire decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call instance.autowire(fn)() . The autowire method will return a function where all the arguments that the container knows about are passed.","title":"Multiple containers"},{"location":"multiple_containers/#multiple-containers","text":"As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers. The default wireup.container is simply an instance just like any other. If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators. To wire parameters use initialization context or the wire method. The wire method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire. Use of @autowire decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call instance.autowire(fn)() . The autowire method will return a function where all the arguments that the container knows about are passed.","title":"Multiple Containers"},{"location":"examples/fastapi/","text":"Fastapi example The example below shows a simple implementation in a Fastapi application. The concepts are generic enough to be applicable to other python frameworks as well. import os import random from dataclasses import dataclass from typing import Optional from fastapi import FastAPI from wireup import container, wire app = FastAPI() # Dependency that can greet in many languages @container.register class GreeterService: @staticmethod def greet(name: str) -> str: return \"{} {}\".format(random.choice([\"Hi\", \"Oye\", \"P\u00ebrsh\u00ebndetje\", \"Guten Tag\"]), name) @container.register @dataclass class DummyService: # Dataclass attributes will be automatically injected if known by the container. greeter: GreeterService # Parameters cannot be located from type alone, so they need some more information. # Get parameter with a given name. env: str = wire(param=\"env\") # Interpolate parameters within curly brackets. logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\") def dummy(self): return f\"Running in env={self.env}; Storing cache in {self.logs_cache_dir}\" @app.get(\"/\") @container.autowire async def root( # This is a fastapi query parameter. name: Optional[str] = None, # Default value is not needed by the container, it is only to make fastapi happy. # It is the equivalent of Depends(lambda: None) # and will have to be used for any deps that are to be injected. # When using other frameworks the wire() call can be omitted. dummy_service: DummyService = wire(), logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\"), ): # If you really need to, you can also get dependencies this way. # And use the container in a service locator manner. # Although injection is the recommended way this is left available for cases # where dynamic loading of some sort is required. # This however is still a hard dependency that is not getting injected. greeter = container.get(GreeterService) return { \"greeting\": greeter.greet(name), \"cache_dir\": logs_cache_dir, \"dummy\": dummy_service.dummy(), } # Register individual parameters in the container container.params.put(\"cache_dir\", \"/var/cache\") container.params.put(\"env\", \"prod\") container.params.put(\"auth.user\", \"anon\") # Merge current values using the ones from the dict. container.params.update(dict(os.environ))","title":"Fastapi"},{"location":"examples/fastapi/#fastapi-example","text":"The example below shows a simple implementation in a Fastapi application. The concepts are generic enough to be applicable to other python frameworks as well. import os import random from dataclasses import dataclass from typing import Optional from fastapi import FastAPI from wireup import container, wire app = FastAPI() # Dependency that can greet in many languages @container.register class GreeterService: @staticmethod def greet(name: str) -> str: return \"{} {}\".format(random.choice([\"Hi\", \"Oye\", \"P\u00ebrsh\u00ebndetje\", \"Guten Tag\"]), name) @container.register @dataclass class DummyService: # Dataclass attributes will be automatically injected if known by the container. greeter: GreeterService # Parameters cannot be located from type alone, so they need some more information. # Get parameter with a given name. env: str = wire(param=\"env\") # Interpolate parameters within curly brackets. logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\") def dummy(self): return f\"Running in env={self.env}; Storing cache in {self.logs_cache_dir}\" @app.get(\"/\") @container.autowire async def root( # This is a fastapi query parameter. name: Optional[str] = None, # Default value is not needed by the container, it is only to make fastapi happy. # It is the equivalent of Depends(lambda: None) # and will have to be used for any deps that are to be injected. # When using other frameworks the wire() call can be omitted. dummy_service: DummyService = wire(), logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\"), ): # If you really need to, you can also get dependencies this way. # And use the container in a service locator manner. # Although injection is the recommended way this is left available for cases # where dynamic loading of some sort is required. # This however is still a hard dependency that is not getting injected. greeter = container.get(GreeterService) return { \"greeting\": greeter.greet(name), \"cache_dir\": logs_cache_dir, \"dummy\": dummy_service.dummy(), } # Register individual parameters in the container container.params.put(\"cache_dir\", \"/var/cache\") container.params.put(\"env\", \"prod\") container.params.put(\"auth.user\", \"anon\") # Merge current values using the ones from the dict. container.params.update(dict(os.environ))","title":"Fastapi example"}]}