{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WireUp Dependency and configuration injection library in Python. 1. Set application configuration parameters container.params.update({ \"db.connection_str\": \"sqlite://\", \"auth.user\": os.environ.get(\"USER\"), \"cache_dir\": \"/var/cache/\", \"env\": os.environ.get(\"ENV\", \"dev\") }) 2. Register dependencies @container.register class DbService: def __init__( self, # Inject a parameter by name connection_str: str = wire(param=\"db.connection_str\"), # Or by interpolating multiple parameters into a string cache_dir: str = wire(expr=\"${cache_dir}/${auth.user}/db\"), ): self.connection_str = connection_str self.cache_dir = cache_dir # Constructor injection is also supported for dataclasses # resulting in a more compact syntax. @container.register @dataclass class UserRepository: db: DbService # Dependencies may also depend on other dependencies. user: str = container.wire(param=\"auth.user\") 3. Inject # Decorate all methods where the library must perform injection. @app.route(\"/greet/<str:name>\") @container.autowire # Classes are automatically injected based on annotated type. # Parameters will be located based on the hint given in their default value. # Unknown arguments will not be processed. def greet(name: str, user_repository: UserRepository, env: str = wire(param=\"env\")): ... Installation # Install using poetry: poetry add wireup # Install using pip: pip install wireup","title":"Home"},{"location":"#wireup","text":"Dependency and configuration injection library in Python. 1. Set application configuration parameters container.params.update({ \"db.connection_str\": \"sqlite://\", \"auth.user\": os.environ.get(\"USER\"), \"cache_dir\": \"/var/cache/\", \"env\": os.environ.get(\"ENV\", \"dev\") }) 2. Register dependencies @container.register class DbService: def __init__( self, # Inject a parameter by name connection_str: str = wire(param=\"db.connection_str\"), # Or by interpolating multiple parameters into a string cache_dir: str = wire(expr=\"${cache_dir}/${auth.user}/db\"), ): self.connection_str = connection_str self.cache_dir = cache_dir # Constructor injection is also supported for dataclasses # resulting in a more compact syntax. @container.register @dataclass class UserRepository: db: DbService # Dependencies may also depend on other dependencies. user: str = container.wire(param=\"auth.user\") 3. Inject # Decorate all methods where the library must perform injection. @app.route(\"/greet/<str:name>\") @container.autowire # Classes are automatically injected based on annotated type. # Parameters will be located based on the hint given in their default value. # Unknown arguments will not be processed. def greet(name: str, user_repository: UserRepository, env: str = wire(param=\"env\")): ... Installation # Install using poetry: poetry add wireup # Install using pip: pip install wireup","title":"WireUp"},{"location":"factory_functions/","text":"Factory functions Factory functions allow the container to wire dependencies that require additional logic to create or be able to inject objects it doesn't own. Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate the creation of an object to a special function called a factory . Use cases Some of the use cases for factories are as follows: Object construction needs additional logic or configuration. Depending on the runtime environment or configuration, you may need to create different objects inheriting from the same base (See Strategy Pattern ) or configure them differently. Gradually introduce DI into an existing project where the container should be able to inject dependencies created elsewhere. Such as injecting the same databaser connection as the rest of the application. Eliminate services which have only one method that returns the same object and instead inject the object directly. A service that returns a db connection A service which returns the current authenticated user Register the result of a service's method as its own service. Instead of calling auth_service.get_current_user() every time, inject the authenticated user directly. Usage In order for the container to be able to inject these dependencies you must register the factory function. You can do this by using the @container.register decorator or by calling container.register(fn) directly. When the container needs to inject a dependency it checks known factories to see if any of them can create it. Info The return type of the function tells the container what type of dependency it can create. Warning Factories can only depend on objects known by the container! Examples Assume in the context of a web application a class User exists and represents a user of the system. # Instead of doing the following over and over again def get_user_logs(auth_service: AuthService): current_user = auth_service.get_current_user() ... # You can create a factory and inject the authenticated user directly. # You may want to create a new type to make a disctinction on the type of user this is. AuthenticatedUser = User @container.register def get_current_user(auth_service: AuthService) -> AuthenticatedUser: return auth_service.get_current_user() # Now it is possible to inject the authenticated user directly wherever it is necessary. def get_user_logs(user: AuthenticatedUser): ... Links Introduce to an existing project","title":"Factory functions"},{"location":"factory_functions/#factory-functions","text":"Factory functions allow the container to wire dependencies that require additional logic to create or be able to inject objects it doesn't own. Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate the creation of an object to a special function called a factory .","title":"Factory functions"},{"location":"factory_functions/#use-cases","text":"Some of the use cases for factories are as follows: Object construction needs additional logic or configuration. Depending on the runtime environment or configuration, you may need to create different objects inheriting from the same base (See Strategy Pattern ) or configure them differently. Gradually introduce DI into an existing project where the container should be able to inject dependencies created elsewhere. Such as injecting the same databaser connection as the rest of the application. Eliminate services which have only one method that returns the same object and instead inject the object directly. A service that returns a db connection A service which returns the current authenticated user Register the result of a service's method as its own service. Instead of calling auth_service.get_current_user() every time, inject the authenticated user directly.","title":"Use cases"},{"location":"factory_functions/#usage","text":"In order for the container to be able to inject these dependencies you must register the factory function. You can do this by using the @container.register decorator or by calling container.register(fn) directly. When the container needs to inject a dependency it checks known factories to see if any of them can create it. Info The return type of the function tells the container what type of dependency it can create. Warning Factories can only depend on objects known by the container!","title":"Usage"},{"location":"factory_functions/#examples","text":"Assume in the context of a web application a class User exists and represents a user of the system. # Instead of doing the following over and over again def get_user_logs(auth_service: AuthService): current_user = auth_service.get_current_user() ... # You can create a factory and inject the authenticated user directly. # You may want to create a new type to make a disctinction on the type of user this is. AuthenticatedUser = User @container.register def get_current_user(auth_service: AuthService) -> AuthenticatedUser: return auth_service.get_current_user() # Now it is possible to inject the authenticated user directly wherever it is necessary. def get_user_logs(user: AuthenticatedUser): ...","title":"Examples"},{"location":"factory_functions/#links","text":"Introduce to an existing project","title":"Links"},{"location":"interfaces/","text":"Working with Interfaces When autowiring dependencies, you might want to inject an interface rather than the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class that's marked as abstract within the container. The following code registers Engine as an interface. This implies that Engine can't be directly injected. Instead, a dependency that implements the interface must be present and also be registered in the container. @container.abstract class Engine: def do_thing(self): ... To autowire interfaces, you can simply register a dependency that implements the interface within the container. When injecting, ask for the interface itself, not its concrete implementation. @container.register class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" @container.autowire def do_engine_things(engine: Engine): return engine.do_thing() # Returns \"I'm a Combustion Engine\" In scenarios where there are multiple implementations of an interface, each implementation must be associated with a qualifier. @container.register(qualifier=\"electric\") class ElectricEngine(Engine): def do_thing(self): return \"I'm an Electric Engine\" @container.register(qualifier=\"combustion\") class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" While injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate which concrete class should be resolved. def home( engine: Engine = wire(qualifier=\"electric\"), combustion: Engine = wire(qualifier=\"combustion\"), ): ...","title":"Working with Interfaces"},{"location":"interfaces/#working-with-interfaces","text":"When autowiring dependencies, you might want to inject an interface rather than the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class that's marked as abstract within the container. The following code registers Engine as an interface. This implies that Engine can't be directly injected. Instead, a dependency that implements the interface must be present and also be registered in the container. @container.abstract class Engine: def do_thing(self): ... To autowire interfaces, you can simply register a dependency that implements the interface within the container. When injecting, ask for the interface itself, not its concrete implementation. @container.register class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" @container.autowire def do_engine_things(engine: Engine): return engine.do_thing() # Returns \"I'm a Combustion Engine\" In scenarios where there are multiple implementations of an interface, each implementation must be associated with a qualifier. @container.register(qualifier=\"electric\") class ElectricEngine(Engine): def do_thing(self): return \"I'm an Electric Engine\" @container.register(qualifier=\"combustion\") class CombustionEngine(Engine): def do_thing(self): return \"I'm a Combustion Engine\" While injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate which concrete class should be resolved. def home( engine: Engine = wire(qualifier=\"electric\"), combustion: Engine = wire(qualifier=\"combustion\"), ): ...","title":"Working with Interfaces"},{"location":"introduce_to_an_existing_project/","text":"Introduce to an existing project It can be challenging to add DI to an existing project which doesn't yet use it. One of the issues you will run into sooner or later is being able to share resources between code which uses DI and the rest of the application which does not. This is especially useful to allow the container to inject dependencies created elsewhere. Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, you can instruct the container how to get the connection either via a service or by using factory functions. Another case might be an existing service that is already constructed, and you wish to be able to inject. Using a Service A typical way to solve this would involve create a service with a single method that uses existing functionality to get the desired object and simply returns it. # Example of a service acting as a factory @container.register @dataclass class DbConnectionService: self.conn = get_db_connection_from_somewhere() Here, it is possible inject DbConnectionService and call .conn to get the connection. While this works, it's not the best way to go. Using Factory functions To handle this more elegantly, WireUp lets you register functions as factories. You can do this by using the @container.register decorator or by calling container.register(fn) directly. @container.register def get_db_connection_from_somewhere() -> Connection: return ... # Alternatively container.register(get_db_connection_from_somewhere) Now it is possible to inject Connection just like any other dependency. Links Factory functions","title":"Introduce to an existing project"},{"location":"introduce_to_an_existing_project/#introduce-to-an-existing-project","text":"It can be challenging to add DI to an existing project which doesn't yet use it. One of the issues you will run into sooner or later is being able to share resources between code which uses DI and the rest of the application which does not. This is especially useful to allow the container to inject dependencies created elsewhere. Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, you can instruct the container how to get the connection either via a service or by using factory functions. Another case might be an existing service that is already constructed, and you wish to be able to inject.","title":"Introduce to an existing project"},{"location":"introduce_to_an_existing_project/#using-a-service","text":"A typical way to solve this would involve create a service with a single method that uses existing functionality to get the desired object and simply returns it. # Example of a service acting as a factory @container.register @dataclass class DbConnectionService: self.conn = get_db_connection_from_somewhere() Here, it is possible inject DbConnectionService and call .conn to get the connection. While this works, it's not the best way to go.","title":"Using a Service"},{"location":"introduce_to_an_existing_project/#using-factory-functions","text":"To handle this more elegantly, WireUp lets you register functions as factories. You can do this by using the @container.register decorator or by calling container.register(fn) directly. @container.register def get_db_connection_from_somewhere() -> Connection: return ... # Alternatively container.register(get_db_connection_from_somewhere) Now it is possible to inject Connection just like any other dependency.","title":"Using Factory functions"},{"location":"introduce_to_an_existing_project/#links","text":"Factory functions","title":"Links"},{"location":"introduction/","text":"Introduction WireUp is a Python library designed to provide a powerful and flexible way to manage and inject dependencies across your application, making it easier to develop, test, and maintain your codebase. Key features include: Dependency Injection: Effortlessly inject dependencies into your classes and functions using a clean and intuitive syntax. Lazy loading: Dependencies injected by the library are lazily loaded and will be only initialized on first use. Singleton dependencies: Every dependency is initialized only once and all references to it will reuse the same instance. Parameter Management: Manage your application's parameters and configuration values supporting parameter interpolation and referencing. Async ready: The library supports autowiring on async methods Framework Integration: Seamlessly integrate with popular web frameworks like FastAPI and Flask to simplify dependency management in web applications. Service Locator: You can use the container to retrieve classes by their type for more advanced use cases.","title":"Introduction"},{"location":"introduction/#introduction","text":"WireUp is a Python library designed to provide a powerful and flexible way to manage and inject dependencies across your application, making it easier to develop, test, and maintain your codebase. Key features include: Dependency Injection: Effortlessly inject dependencies into your classes and functions using a clean and intuitive syntax. Lazy loading: Dependencies injected by the library are lazily loaded and will be only initialized on first use. Singleton dependencies: Every dependency is initialized only once and all references to it will reuse the same instance. Parameter Management: Manage your application's parameters and configuration values supporting parameter interpolation and referencing. Async ready: The library supports autowiring on async methods Framework Integration: Seamlessly integrate with popular web frameworks like FastAPI and Flask to simplify dependency management in web applications. Service Locator: You can use the container to retrieve classes by their type for more advanced use cases.","title":"Introduction"},{"location":"manual_configuration/","text":"Manual Configuration WireUp provides convenient decorators and functions for you to use and perform dependency injection. If using decorators or functions such as wire not appropriate for your application then manual container configuration is also possible. Using wireup without registration decorators In addition to using @container.register to register each dependency, automatic registration is also possible by using the container.regiter_all_in_module(module, pattern = \"*\") method. Module represents the top level module containing all your dependencies, optionally a fnmatch pattern can be specified to only register classes that match the pattern. This is the equivalent of using @container.register on each. container.register_all_in_module(app.service, \"*Service\") Manually wiring parameters Given that parameters can't be resolved from type annotations alone, the container.wire method offers two shortcuts for parameter injection: wire(name=\"\") and wire(expr=\"\") . To achieve the same outcome without relying on default values, you can use the container's initialization context. This allows you to manually provide data that the library would otherwise gather from the decorators. container.register_all_in_module(app.services, \"*Service\") # Register parameters individually using add_param container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=\"connection_str\", ) container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=TemplatedString(\"${cache_dir}/${auth_user}/db\"), ) # Alternatively, you can update the context in bulk using a dictionary of initializer parameter names as keys # and container parameter references as values. # When using interpolated strings, make sure you wrap the string with TemplatedString. container.initialization_context.update( DbService, { \"connection_str\": \"connection_str\", \"cache_dir\": TemplatedString(\"${cache_dir}/${USER}/db\"), }, ) Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.","title":"Manual configuration"},{"location":"manual_configuration/#manual-configuration","text":"WireUp provides convenient decorators and functions for you to use and perform dependency injection. If using decorators or functions such as wire not appropriate for your application then manual container configuration is also possible.","title":"Manual Configuration"},{"location":"manual_configuration/#using-wireup-without-registration-decorators","text":"In addition to using @container.register to register each dependency, automatic registration is also possible by using the container.regiter_all_in_module(module, pattern = \"*\") method. Module represents the top level module containing all your dependencies, optionally a fnmatch pattern can be specified to only register classes that match the pattern. This is the equivalent of using @container.register on each. container.register_all_in_module(app.service, \"*Service\")","title":"Using wireup without registration decorators"},{"location":"manual_configuration/#manually-wiring-parameters","text":"Given that parameters can't be resolved from type annotations alone, the container.wire method offers two shortcuts for parameter injection: wire(name=\"\") and wire(expr=\"\") . To achieve the same outcome without relying on default values, you can use the container's initialization context. This allows you to manually provide data that the library would otherwise gather from the decorators. container.register_all_in_module(app.services, \"*Service\") # Register parameters individually using add_param container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=\"connection_str\", ) container.initialization_context.add_param( klass=DbService, argument_name=\"connection_str\", parameter_ref=TemplatedString(\"${cache_dir}/${auth_user}/db\"), ) # Alternatively, you can update the context in bulk using a dictionary of initializer parameter names as keys # and container parameter references as values. # When using interpolated strings, make sure you wrap the string with TemplatedString. container.initialization_context.update( DbService, { \"connection_str\": \"connection_str\", \"cache_dir\": TemplatedString(\"${cache_dir}/${USER}/db\"), }, ) Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.","title":"Manually wiring parameters"},{"location":"multiple_containers/","text":"Multiple Containers As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers. The default wireup.container is simply an instance just like any other. If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators. To wire parameters use initialization context or the wire method. The wire method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire. Use of @autowire decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call instance.autowire(fn)() . The autowire method will return a function where all the arguments that the container knows about are passed.","title":"Multiple containers"},{"location":"multiple_containers/#multiple-containers","text":"As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers. The default wireup.container is simply an instance just like any other. If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators. To wire parameters use initialization context or the wire method. The wire method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire. Use of @autowire decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call instance.autowire(fn)() . The autowire method will return a function where all the arguments that the container knows about are passed.","title":"Multiple Containers"},{"location":"parameters/","text":"Parameters In addition to service objects, the container also holds configuration, called parameters. Parameters are stored as a flat key-value store. They are able to retrieved at a later time by services when being constructed. Management Parameters are put in the container using its params property and are referenced by their name. It is possible to add items by calling the .put(name, value) method, or in bulk or by calling .update(dict) using a dictionary of name-value pairs. To retrieve a parameter by name directly from the container you can call container.params.get(name) . Note Although the value of the parameters can be anything, they cannot depend on anything else. As such, autowiring services or other parameters on them is not possible. Injection Contrary to services, it is not possible to autowire a parameter solely by its type. To enable autowiring you must use the wire() method as the parameters default value. By name To inject a parameter by name simply call wire(param=\"param_name\") . @container.autowire def do_something_cool(cache_dir: str = wire(param=\"cache_dir\")) -> None: ... Parameter expressions It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together or simply format the value of a single parameter. @container.autowire def do_something_cool(logs_cache_dir: str = wire(expr=\"${cache_dir}/${env}/logs\")) -> None: ... Parameter enums Parameter enums represent an alternative for those who do not want to rely on strings and want to have a typed way to refer to parameter names. You can achieve this by creating a new type inheriting from ParameterEnum . class AppParameters(ParameterEnum): cache_dir = \"cache_dir\" # ... other params follow Using this we can use the enum member whenever we want to refer to a particular parameter. The main feature of the enum is a wire() method which is syntactic sugar for wire(param=AppParameters.cache_dir.value) container.params.put(AppParameters.cache_dir.value, \"/var/cache\") @container.autowire def do_something_cool(cache_dir: str = AppParameters.cache_dir.wire()) -> None: ...","title":"Parameters"},{"location":"parameters/#parameters","text":"In addition to service objects, the container also holds configuration, called parameters. Parameters are stored as a flat key-value store. They are able to retrieved at a later time by services when being constructed.","title":"Parameters"},{"location":"parameters/#management","text":"Parameters are put in the container using its params property and are referenced by their name. It is possible to add items by calling the .put(name, value) method, or in bulk or by calling .update(dict) using a dictionary of name-value pairs. To retrieve a parameter by name directly from the container you can call container.params.get(name) . Note Although the value of the parameters can be anything, they cannot depend on anything else. As such, autowiring services or other parameters on them is not possible.","title":"Management"},{"location":"parameters/#injection","text":"Contrary to services, it is not possible to autowire a parameter solely by its type. To enable autowiring you must use the wire() method as the parameters default value.","title":"Injection"},{"location":"parameters/#by-name","text":"To inject a parameter by name simply call wire(param=\"param_name\") . @container.autowire def do_something_cool(cache_dir: str = wire(param=\"cache_dir\")) -> None: ...","title":"By name"},{"location":"parameters/#parameter-expressions","text":"It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together or simply format the value of a single parameter. @container.autowire def do_something_cool(logs_cache_dir: str = wire(expr=\"${cache_dir}/${env}/logs\")) -> None: ...","title":"Parameter expressions"},{"location":"parameters/#parameter-enums","text":"Parameter enums represent an alternative for those who do not want to rely on strings and want to have a typed way to refer to parameter names. You can achieve this by creating a new type inheriting from ParameterEnum . class AppParameters(ParameterEnum): cache_dir = \"cache_dir\" # ... other params follow Using this we can use the enum member whenever we want to refer to a particular parameter. The main feature of the enum is a wire() method which is syntactic sugar for wire(param=AppParameters.cache_dir.value) container.params.put(AppParameters.cache_dir.value, \"/var/cache\") @container.autowire def do_something_cool(cache_dir: str = AppParameters.cache_dir.wire()) -> None: ...","title":"Parameter enums"},{"location":"examples/fastapi/","text":"FastAPI example The example below shows a simple implementation in a FastAPI application. The concepts are generic enough to be applicable to other python frameworks as well. import os import random from dataclasses import dataclass from typing import Optional from fastapi import FastAPI from wireup import container, wire app = FastAPI() # Dependency that can greet in many languages @container.register class GreeterService: @staticmethod def greet(name: str) -> str: return \"{} {}\".format(random.choice([\"Hi\", \"Oye\", \"P\u00ebrsh\u00ebndetje\", \"Guten Tag\"]), name) @container.register @dataclass class DummyService: # Dataclass attributes will be automatically injected if known by the container. greeter: GreeterService # Parameters cannot be located from type alone, so they need some more information. # Get parameter with a given name. env: str = wire(param=\"env\") # Interpolate parameters within curly brackets. logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\") def dummy(self): return f\"Running in env={self.env}; Storing cache in {self.logs_cache_dir}\" @app.get(\"/\") @container.autowire async def root( # This is a FastAPI query parameter. name: Optional[str] = None, # Default value is not needed by the container, it is only to make FastAPI happy. # It is the equivalent of Depends(lambda: None) # and will have to be used for any deps that are to be injected. # When using other frameworks the wire() call can be omitted. dummy_service: DummyService = wire(), logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\"), ): # If you really need to, you can also get dependencies this way. # And use the container in a service locator manner. # Although injection is the recommended way this is left available for cases # where dynamic loading of some sort is required. # This however is still a hard dependency that is not getting injected. greeter = container.get(GreeterService) return { \"greeting\": greeter.greet(name), \"cache_dir\": logs_cache_dir, \"dummy\": dummy_service.dummy(), } # Register individual parameters in the container container.params.put(\"cache_dir\", \"/var/cache\") container.params.put(\"env\", \"prod\") container.params.put(\"auth.user\", \"anon\") # Merge current values using the ones from the dict. container.params.update(dict(os.environ))","title":"FastAPI"},{"location":"examples/fastapi/#fastapi-example","text":"The example below shows a simple implementation in a FastAPI application. The concepts are generic enough to be applicable to other python frameworks as well. import os import random from dataclasses import dataclass from typing import Optional from fastapi import FastAPI from wireup import container, wire app = FastAPI() # Dependency that can greet in many languages @container.register class GreeterService: @staticmethod def greet(name: str) -> str: return \"{} {}\".format(random.choice([\"Hi\", \"Oye\", \"P\u00ebrsh\u00ebndetje\", \"Guten Tag\"]), name) @container.register @dataclass class DummyService: # Dataclass attributes will be automatically injected if known by the container. greeter: GreeterService # Parameters cannot be located from type alone, so they need some more information. # Get parameter with a given name. env: str = wire(param=\"env\") # Interpolate parameters within curly brackets. logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\") def dummy(self): return f\"Running in env={self.env}; Storing cache in {self.logs_cache_dir}\" @app.get(\"/\") @container.autowire async def root( # This is a FastAPI query parameter. name: Optional[str] = None, # Default value is not needed by the container, it is only to make FastAPI happy. # It is the equivalent of Depends(lambda: None) # and will have to be used for any deps that are to be injected. # When using other frameworks the wire() call can be omitted. dummy_service: DummyService = wire(), logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\"), ): # If you really need to, you can also get dependencies this way. # And use the container in a service locator manner. # Although injection is the recommended way this is left available for cases # where dynamic loading of some sort is required. # This however is still a hard dependency that is not getting injected. greeter = container.get(GreeterService) return { \"greeting\": greeter.greet(name), \"cache_dir\": logs_cache_dir, \"dummy\": dummy_service.dummy(), } # Register individual parameters in the container container.params.put(\"cache_dir\", \"/var/cache\") container.params.put(\"env\", \"prod\") container.params.put(\"auth.user\", \"anon\") # Merge current values using the ones from the dict. container.params.update(dict(os.environ))","title":"FastAPI example"}]}