{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wireup","text":"<p>Dependency injection container with a focus on developer experience, type safety and ease of use.</p> <p>New: Dependency injection for Flask</p> <p>Simplify usage in Flask applications by using the new Flask integration!</p> <ul> <li>Automatically inject dependencies on views without having to manually decorate.</li> <li>Expose Flask application configuration in the container.</li> </ul>"},{"location":"#key-features","title":"Key features","text":"Dependency Injection                  Inject services and configuration using a clean and intuitive syntax.                    Auto-configuration                  Automatically inject dependencies based on their types without additional configuration.                    Short and long-lived processes                  Suitable for use in long-running as well as short-lived processes.         Preload services for performance or lazily inject to instantiate only what you use.                    Interfaces / Abstract classes                  Define abstract types and have the container automatically inject the implementation.                    Multiple Containers                  Use the provided container or instantiate and use multiple ones depending on your project's needs.                   Factory pattern                  Defer instantiation to specialized factories for full control over object creation when necessary.                    Singletons/Transient dependencies                  Declare dependencies as transient or singletons which tells the container whether          to inject a fresh copy or reuse existing instances.                    Framework Agnostic                  Seamlessly integrate with popular web frameworks like Django, Flask and FastAPI         to simplify dependency management."},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"annotations/","title":"Annotations","text":"<p>Autowiring relies on annotations or hints to be able to inject dependencies. When it is not possible to automatically locate a given dependency the argument must be annotated with additional metadata.</p> <p>Note</p> <p>Although using annotations is recommended, they are entirely optional. For more info see: Manual Configuration.</p>"},{"location":"annotations/#when-do-you-need-to-provide-annotations","title":"When do you need to provide annotations.","text":"Injecting Annotations required? What is required Services No Interface with only one implementation No Interface with multiple implementations Yes Qualifier Parameters Yes Parameter name Parameter expressions Yes Parameter expression"},{"location":"annotations/#annotation-types","title":"Annotation types","text":"<p>Wireup supports two types of annotations. Using Python's <code>Annotated</code> or by using default values.</p>"},{"location":"annotations/#annotated","title":"Annotated","text":"<p>This is the preferred method for Python 3.9+ and moving forward. It is also recommended to backport this using <code>typing_extensions</code> for Python 3.8.</p> <pre><code>@container.autowire\ndef target(\n    env: Annotated[str, Wire(param=\"env_name\")],\n    logs_cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/logs\")],\n):\n    ...\n</code></pre>"},{"location":"annotations/#default-values","title":"Default values","text":"<p>This relies on the use of default values to inject parameters. Anything that can be passed to <code>Annotated</code> may also be used here.</p> <pre><code>@container.autowire\ndef target(\n    env: str = wire(param=\"env_name\"), \n    logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\")\n):\n    ...\n</code></pre>"},{"location":"annotations/#explicit-injection-annotation","title":"Explicit injection annotation","text":"<p>Even though annotating services is optional, you CAN still annotate them to be explicit about what will   be injected. This also has the benefit of making the container throw when such as service  does not exist instead of silently skipping this parameter.</p> <pre><code>@container.autowire\ndef target(random_service: Annotated[RandomService, Wire()]):\n    ...\n</code></pre>"},{"location":"demo_app/","title":"Demo application","text":"<p>Check out maldoinc/wireup-demo  for a demo Flask application using Wireup.</p> <p>It shows creation, injection and testing in the context of a simple \"Blog\" application.</p>"},{"location":"factory_functions/","title":"Factory functions","text":"<p>Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate the creation of an object to a special function called a  factory.</p>"},{"location":"factory_functions/#use-cases","title":"Use cases","text":"<p>Some of the use cases for factories are as follows:</p> <ul> <li>Object construction needs additional logic or configuration.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base (See: Strategy Pattern) or configure them differently. </li> <li>Gradually introduce DI into an existing project where the container should be able to inject dependencies created elsewhere.  Such as injecting the same database connection as the rest of the application.</li> <li>Eliminate services which have only one method that returns the same object and instead inject the object directly.<ul> <li>Register the result of a service's method as its own service. Instead of calling <code>db_service.get_db()</code> every time,   inject the session directly.</li> </ul> </li> <li>Inject a model/dto which represents the result of an action, such as the current authenticated user.</li> </ul>"},{"location":"factory_functions/#usage","title":"Usage","text":"<p>In order for the container to inject these dependencies you must register the factory function. You can do this by using the <code>@container.register</code> decorator or by calling <code>container.register(fn)</code> directly.</p> <p>When the container needs to inject a dependency it checks known factories to see if any of them can create it.</p> <p>Info</p> <ul> <li>The return type of the function is mandatory to annotate as tells the container what  type of dependency it can create.</li> <li>Factories can only depend on objects known by the container!</li> </ul> <p>Warning</p> <p>Modules which perform service registration need to be imported otherwise any <code>@container.register</code> calls will not be triggered. This can be an issue when the service does not reside in the same file as the factory. </p> <p>E.g: A model residing in <code>app.model.user</code> and the factory being in <code>app.service.factory</code>. If <code>app.service.factory</code> is never imported the container won't know how to build the user model.</p> <p>In those cases use <code>import_util.load_module</code> once on startup in order to trigger registrations.</p>"},{"location":"factory_functions/#examples","title":"Examples","text":"<p>Assume in the context of a web application a class <code>User</code> exists and represents a user of the system.</p> <pre><code># Instead of doing the following over and over again\ndef get_user_logs(auth_service: AuthService):\n    current_user = auth_service.get_current_user()\n    ...\n\n\n\n# You can create a factory and inject the authenticated user directly.\n# You may want to create a new type to make a disctinction on the type of user this is.\nAuthenticatedUser = NewType(\"AuthenticatedUser\", User)\n\n@container.register(lifetime=ServiceLifetime.TRANSIENT)\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return AuthenticatedUser(auth_service.get_current_user())\n\n# Now it is possible to inject the authenticated user directly wherever it is necessary.\ndef get_user_logs(user: AuthenticatedUser):\n    ...\n</code></pre> <p>Assume a base class <code>Notifier</code> with implementations that define how the notification is sent (IMAP, POP, WebHooks, etc.) Given a user it is possible to instantiate the correct type of notifier based on user preferences.</p> <pre><code>@container.register(lifetime=ServiceLifetime.TRANSIENT)\ndef get_user_notifier(user: AuthenticatedUser) -&gt; Notifier:\n    notifier_type = ...\n\n    return container.get(notifier_type)\n</code></pre> <p>When injecting <code>Notifier</code> the correct type will be created based on the authenticated user's preferences.</p>"},{"location":"factory_functions/#links","title":"Links","text":"<ul> <li>Introduce to an existing project</li> </ul>"},{"location":"interfaces/","title":"Interfaces","text":"<p>When autowiring dependencies, you might want to inject an interface rather than  the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class  that's marked as abstract within the container.</p> <p>This method helps to make testing easier as you can create dummy implementations of these services in your tests in order to control their behavior.</p>"},{"location":"interfaces/#example","title":"Example","text":"<p>The following code registers <code>Engine</code> as an interface. This implies that <code>Engine</code> can't be directly injected.  Instead, a dependency that implements the interface must be present and also be registered in the container.</p> <p>To autowire interfaces, register a dependency that directly inherits the interface  within the container. When injecting, ask for the interface itself, not any of the implementations.</p> <pre><code>@container.abstract\nclass Engine(abc.ABC):\n    def get_type(self) -&gt; EngineType:\n        raise NotImplementedError()\n\n\n@container.register\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@container.autowire\ndef target(engine: Engine):\n    engine_type = engine.get_type() # Returns EngineType.COMBUSTION\n    ...\n</code></pre>"},{"location":"interfaces/#multiple-implementations","title":"Multiple implementations","text":"<p>In scenarios where there are multiple implementations of an interface, each implementation must be  associated with a qualifier.</p> <pre><code>@container.register(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    @override\n    def get_type(self):\n        return EngineType.ELECTRIC\n\n\n@container.register(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n</code></pre> <p>When injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate  which concrete class should be resolved.</p> <pre><code>container.autowire\ndef target(\n    engine: Annotated[Engine, Wire(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Wire(qualifier=\"combustion\")],\n):\n    ...\n</code></pre> <p>Tip</p> <p>Qualifiers can be anything, not just strings! For the above example, <code>EngineType</code> enum members could have been used as qualifiers just as well.</p>"},{"location":"interfaces/#default-implementation","title":"Default implementation","text":"<p>When there are many implementations associated with a given interface you may want to associate one of them as the \"default\" implementation. This means that the container will inject that when there is no qualifier specified even though there are multiple implementations registered.</p> <p>To achieve that simply omit the qualifier when registering.</p> <pre><code>@container.register  # &lt;-- Qualifier being absent will make this the default impl.\nclass ElectricEngine(Engine):\n    pass\n\n@container.register(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    pass\n</code></pre> <p>In the above example when asking for <code>Engine</code> the container will inject <code>ElectricEngine</code>. For the other implementations  you need to specify the qualifier as usual.</p>"},{"location":"introduce_to_an_existing_project/","title":"Introduce to an existing project","text":"<p>It can be challenging to add DI to an existing project which doesn't yet use it. One of the issues you will run into sooner or later is being able to share resources between code which uses DI and the rest of the application  which does not. </p> <p>This is especially useful to allow the container to inject dependencies created elsewhere.</p> <p>Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, you can instruct the container how to get the connection either via a service or by using factory functions.</p> <p>Another case might be an existing service that is already constructed, and you want to inject.</p>"},{"location":"introduce_to_an_existing_project/#using-a-service","title":"Using a Service","text":"<p>A typical way to solve this would involve create a service with a single method  that uses existing functionality to get the desired object and returns it.</p> <pre><code># Example of a service acting as a factory\n@container.register\n@dataclass\nclass DbConnectionService:\n    self.conn = get_db_connection_from_somewhere()\n</code></pre> <p>Here, it is possible inject <code>DbConnectionService</code> and call <code>.conn</code> to get the connection. While this works, it's not the best way to go.</p>"},{"location":"introduce_to_an_existing_project/#using-factory-functions","title":"Using Factory functions","text":"<p>To handle this more elegantly, Wireup lets you register functions as factories.  You can do this by using the <code>@container.register</code> decorator or by calling <code>container.register(fn)</code> directly.</p> <pre><code>@container.register\ndef get_db_connection_from_somewhere() -&gt; Connection:\n    return ...\n\n# Alternatively\n\ncontainer.register(get_db_connection_from_somewhere)\n</code></pre> <p>Now it is possible to inject <code>Connection</code> just like any other dependency. </p>"},{"location":"introduce_to_an_existing_project/#links","title":"Links","text":"<ul> <li>Factory functions</li> </ul>"},{"location":"manual_configuration/","title":"Manual configuration","text":"<p>Wireup provides convenient decorators and functions for you to use and configure service objects. If using them is not appropriate for the project, or you want to keep service objects free of wireup imports, manual configuration is also possible.</p>"},{"location":"manual_configuration/#using-factory-functions","title":"Using factory functions","text":"<p>With this method you keep service objects free of any annotations and instead use factory functions to create them. The function requests any dependencies necessary to create the service and instantiates it.</p> <pre><code># service/translator.py\n@dataclass\nclass TranslatorService:\n    default_locale: str\n\n# service/greeter.py\n@dataclass\nclass GreeterService:\n    translator: TranslatorService\n\n\n# service/factories.py\n# Factory functions will have to be registered and use annotations as usual.\n@container.register\ndef translator_factory(\n    default_locale: Annotated[str, Wire(param=\"default_locale\")],\n) -&gt; TranslatorService:\n    return TranslatorService(default_locale)\n\n\n@container.register\ndef greeter_factory(translator: TranslatorService) -&gt; GreeterService:\n    return GreeterService(translator)\n</code></pre>"},{"location":"manual_configuration/#using-initialization-context","title":"Using initialization context","text":"<p>In addition to using <code>@container.register</code> to register each dependency, automatic registration is also possible by using the <code>wireup.register_all_in_module</code> method. You can use this to import any classes that match a <code>fnmatch</code> pattern or a regular expression.</p> <p>Module represents the top level module containing all your dependencies, optionally a <code>fnmatch</code> pattern can be specified to only register classes that match the pattern. This is the equivalent of using <code>@container.register</code> on each.</p> <pre><code>wireup.register_all_in_module(app.service, \"*Service\")\n</code></pre> <p>Tip</p> <p>Register services either using <code>register_all_in_module</code> or by calling <code>container.register</code> on each. Doing so will automatically discover all non-parameter dependencies.</p>"},{"location":"manual_configuration/#interfaces","title":"Interfaces","text":"<p>Even though It's not possible to automatically register abstract types and implementation using qualifiers.  Manual registration is still possible.</p> <pre><code>container.abstract(FooBase)\ncontainer.register(FooBar, qualifier=\"bar\")\ncontainer.register(FooBaz, qualifier=\"baz\")\n</code></pre>"},{"location":"manual_configuration/#manually-wiring-parameters","title":"Manually wiring parameters","text":"<p>Given that parameters can't be resolved from type annotations alone, they must be annotated.</p> <p>To achieve the same outcome without relying on annotations, you can use the container's  initialization context. This allows you to manually provide data that the library would  otherwise gather from the decorators or annotations.</p> <p><pre><code>wireup.register_all_in_module(app.services, \"*Service\")\n\n# Register parameters individually using add_dependency\ncontainer.context.add_dependency(\n    klass=DbService,\n    argument_name=\"connection_str\",\n    value=AnnotatedParameter(annotation=ParameterWrapper(\"connection_str\")),\n)\ncontainer.context.add_dependency(\n    klass=DbService,\n    argument_name=\"connection_str\",\n    value=AnnotatedParameter(\n        annotation=ParameterWrapper(TemplatedString(\"${cache_dir}/${auth_user}/db\"))\n    ),\n)\n</code></pre> Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.</p>"},{"location":"multiple_containers/","title":"Multiple containers","text":"<p>As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers.</p> <ul> <li>The default <code>wireup.container</code> is an instance just like any other.</li> <li>If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators.</li> <li>To wire parameters use initialization context or the <code>wire</code> method. The <code>wire</code> method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire.</li> <li>Use of <code>@autowire</code> decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call <code>instance.autowire(fn)()</code>. The autowire method will return a function where all the arguments that the container knows about are passed.</li> </ul>"},{"location":"optimizing_container/","title":"Optimizing the container","text":"<p>The container can be adjusted for either short or long-lived processes. A short-lived process may be a cli command that is part of a broader application. Whereas a long-lived process may be an Api that listens and serves requests.</p> <p>Note</p> <p>To warm up, use <code>warmup_container</code> from the <code>wireup</code> module.</p>"},{"location":"optimizing_container/#under-the-hood","title":"Under the hood","text":"<p>When decorating with <code>@register</code> or <code>@autowire</code>, the container doesn't know yet the final set of services so when it performs autowiring it injects proxy objects. These act and behave the same way as the real ones but there is a tiny performance penalty when interacting with them.</p> <p>After warmup, the container will assume the current dependency set is the final one and will create only real instances for singleton dependencies that way during autowiring there will be no more proxies.</p>"},{"location":"optimizing_container/#recommendations","title":"Recommendations","text":"<ul> <li>For simple commands which will perform a small number of tasks then exit it is recommended to not use  <code>warmup_container</code>. This will mean that only objects used during the lifetime of the command will be used instead of instantiating all services.</li> <li>For long-lived processes where all these objects will be instantiated anyway, it is recommended to use  <code>warmup_container</code> to minimize performance penalty incurred by autowiring.</li> </ul>"},{"location":"parameters/","title":"Parameters","text":"<p>In addition to service objects, the container also holds configuration, called parameters.  Think of a database url or environment name.</p> <p>Warning</p> <p>Parameters represent application configuration.  They are not intended for the developers to pass values around or to be used as a global session object.</p> <p>Store only app configuration such as environment name, database url, mailer url etc.</p>"},{"location":"parameters/#management","title":"Management","text":"<p>Parameters are put in the container using its <code>params</code> property and are referenced by their name. It is possible to add items by calling the <code>.put(name, value)</code> method, or in bulk or by calling <code>.update(dict)</code>  using a dictionary of name-value pairs.</p> <p>To retrieve a parameter by name directly from the container you can call <code>container.params.get(name)</code>.</p> <p>Note</p> <p>Although the value of the parameters can be anything; including classes,  they cannot depend on anything else.  As such, autowiring services or other parameters on them is not possible.</p>"},{"location":"parameters/#injection","title":"Injection","text":"<p>Contrary to services, it is not possible to autowire a parameter solely by its type. To enable autowiring you must annotate the function parameter with the parameter name or expression being injected.</p>"},{"location":"parameters/#by-name","title":"By name","text":"<p>To inject a parameter by name annotate the type with <code>Wire(param=\"param_name\")</code>.</p> <pre><code>@container.autowire\ndef target(cache_dir: Annotated[str, Wire(param=\"cache_dir\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#parameter-expressions","title":"Parameter expressions","text":"<p>It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together or concatenate the value of a single parameter.</p> <p>Note: As the result is a string, any non-string parameters will be converted using <code>str()</code>.</p> <pre><code>@container.autowire\ndef target(logs_cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/${env}/logs\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#parameter-enums","title":"Parameter enums","text":"<p>Parameter enums represent an alternative for those who do not want to rely on strings and want to have a typed way to refer to parameter names. You can achieve this by creating a new type inheriting from <code>ParameterEnum</code>.</p> <p><pre><code>class AppParameters(ParameterEnum):\n    cache_dir = \"cache_dir\"\n    # ... other params follow\n</code></pre> Using this we can use the enum member whenever we want to refer to a particular parameter. The main feature of the enum is a <code>wire()</code> method which is syntactic sugar for <code>wire(param=AppParameters.cache_dir.value)</code></p> <pre><code>container.params.put(AppParameters.cache_dir.value, \"/var/cache\")\n\n@container.autowire\ndef do_something_cool(cache_dir: Annotated[str, AppParameters.cache_dir.wire()]) -&gt; None:\n    ...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Example showing a Database service, a repository and a web view which uses the repository to fetch all posts  from a fictional blog db.</p> <p>1. Register dependencies</p> <pre><code>from wireup import container\n\ncontainer.params.update(app.config.items()) # (3)!\n\n\n@container.register # (1)!\nclass DatabaseService:\n    def __init__(self, connection_url: Annotated[str, Wire(param=\"db_connection_url\")]):\n        self.engine = create_engine(connection_url)\n\n\n@container.register\n@dataclass # (4)!\nclass PostRepository:\n    db: DatabaseService # (2)!\n\n    def find_all(self) -&gt; list[Post]:\n        return self.db.query...\n</code></pre> <ol> <li>Decorators do not modify the classes in any way and only serve to collect metadata. This behavior can make    testing a lot simpler as you can still instantiate this like a regular class in your tests.</li> <li> <ul> <li>Use type hints to indicate which dependency to inject.</li> <li>Services are automatically autowired and do not need the <code>@autowire</code> decorator</li> </ul> </li> <li>Optionally wire parameters, they serve as configuration for services. Think of a database url or environment name.</li> <li>Initializer injection is supported for regular classes as well as dataclasses.</li> </ol> <p>2. Inject</p> <pre><code>@app.get(\"/posts\")\n@container.autowire # (1)!\ndef get_posts(post_repository: PostRepository):\n    return post_repository.find_all()\n</code></pre> <ol> <li>Decorate all methods where the library must perform injection.    Optional when using the Flask    or FastApi integrations.</li> </ol> <p>Installation</p> <pre><code># Install using poetry:\npoetry add wireup\n\n# Install using pip:\npip install wireup\n</code></pre>"},{"location":"services/","title":"Services","text":"<p>Use service objects to implement functionality in your application. Services can depend on configuration or other services.</p>"},{"location":"services/#registration","title":"Registration","text":"<p>Wireup does not enforce a structure, services may live anywhere in the application but must be registered  with the container.</p> <p>To register a class as a service the following options are available.</p> <ul> <li>Decorate the class using <code>container.register</code>.</li> <li>Call <code>container.register(YourService)</code> directly.</li> <li>Use <code>wireup.register_all_in_module</code>.   (See: Manual Configuration)</li> </ul>"},{"location":"services/#lifetime","title":"Lifetime","text":"<p>By default, services will be registered as singletons. If your service or Factory function needs to generate a fresh instance every time it is injected it needs to be registered with the <code>lifetime</code> parameter set to <code>TRANSIENT</code>.</p>"},{"location":"services/#injection","title":"Injection","text":"<p>Injection will be performed based on type hints. Most of the time no manual configuration  is needed to inject services. </p> <p>Tip</p> <p>Refer to the documentation regarding Annotations for the exact details on when you need to explicitly annotate your dependencies.</p>"},{"location":"services/#autowiring","title":"Autowiring","text":"<p>To perform autowiring the method to be autowired must be decorated with <code>@container.autowire</code>. Given the nature of Python decorators it is also possible to call it as a regular function which will return a callable where the container will perform dependency injection when called.</p>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#unit-tests","title":"Unit tests","text":"<p>Unit testing service objects is meant to be easy as the container does not interfere in any way with the underlying classes.</p> <p>All of them can be instantiated as usual in tests, and you need to pass any dependencies  such as services or parameters to them yourself.</p> <p>To specify custom behavior for tests, you can provide a custom implementation  or a subclass that returns test data as a dependency instead of mocks.</p> <p>It is also possible to use the container to build a part of your dependencies by calling <code>container.get(ThingService)</code> which will return a <code>ThingService</code> instance.</p>"},{"location":"testing/#integration-tests","title":"Integration tests","text":"<p>While wireup tries to make it as easy as possible to test services by not modifying the underlying classes in any way even when decorated, sometimes you need to be able to swap a service object on the fly for a different one such as a mock.</p> <p>This process can be useful in testing autowired targets such as an api endpoint  for which there is no easy way to pass a mock object as it's not being called directly by the test.</p> <p>The <code>container.override</code> property provides access to a number of useful methods which will help temporarily overriding dependencies  (See override manager).</p> <p>Good to know</p> <ul> <li>Overriding only applies to future autowire calls.</li> <li>It is possible to override any service directly.</li> <li>Once a singleton service has been instantiated, it is not possible to directly replace any of its direct or transitive dependencies via overriding as the object is already in memory.<ul> <li>You will need to call <code>container.clear_initialized_objects()</code> and then override the  desired service. This will make the container use the override when the  new copy of the service is being built.</li> </ul> </li> <li>When using interfaces and/or qualifiers, override the interface and/or qualifier rather than the implementation  that will be injected.</li> </ul>"},{"location":"testing/#examples","title":"Examples","text":""},{"location":"testing/#context-manager","title":"Context Manager","text":"<pre><code>random_mock = MagicMock()\nrandom_mock.get_random.return_value = 5\n\nwith self.container.override.service(target=RandomService, new=random_mock):\n    # Assuming in the context of a web app:\n    # /random endpoint has a dependency on RandomService\n    # any requests to inject RandomService during the lifetime\n    # of this context manager will result in random_mock being injected instead.\n    response = client.get(\"/random\")\n</code></pre>"},{"location":"testing/#python-unittest","title":"Python unittest","text":"<p>You can use the setup method to replace a service with a mock for the duration of the test. In each method <code>self.db_service</code> is available </p> <pre><code>class SomeEndpointTest(unittest.TestCase):\n    def setUp(self) -&gt; None:\n        self.db_service = MagicMock()\n\n        # Drop all references to initialized objects.\n        # Any services or autowire targets requesting DBService\n        # will get the mocked object instead.\n        container.clear_initialized_objects()\n        container.override.service(DbService, new=self.db_service)\n</code></pre>"},{"location":"testing/#pytest","title":"Pytest","text":"<p>Similar to the above example but this uses pytest's autouse to achieve the same result.</p> <pre><code>@pytest.fixture(autouse=True)\ndef clear_container(db_service_mock) -&gt; Iterator[None]:\n    container.clear_initialized_objects()\n    container.override.service(DbService, new=db_service_mock)\n    yield\n\ndef test_something_with_mocked_db_service(client, db_service_mock):\n    # Set up the db service mock\n    db_service_mock.get_things.return_value = ...\n    response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre>"},{"location":"versioning/","title":"Versioning","text":"<p>This library adheres to Semantic Versioning (Semver) principles to ensure predictable versioning and compatibility for its users. </p> <ul> <li>Semver consists of three distinct version components: MAJOR, MINOR, and PATCH, separated by dots (e.g., 1.2.3). </li> <li>Changes in the MAJOR version indicate backward-incompatible changes, such as breaking API alterations. </li> <li>MINOR version updates signify new, backward-compatible features or enhancements, while PATCH versions are reserved for backward-compatible bug fixes. </li> <li>All releases with a MAJOR version of 0 are considered pre-release and as such, the api is considered unstable.   Minor-version releases may contain breaking changes as the api evolves.</li> <li>The following is considered public API</li> <li>All direct exports of the <code>wireup</code> package.</li> <li>All accessible objects from the public interface of the above exported objects.</li> </ul> <p>Tip</p> <p>When using a pre-release version, pin the constraint to <code>0.x.*</code> so that you don't accidentally upgrade to a version with breaking changes, but are still able to get bug-fix releases.</p>"},{"location":"class/dependency_container/","title":"DependencyContainer","text":"<p>Dependency Injection and Service Locator container registry.</p> <p>This contains all the necessary information to initialize registered classes. Objects instantiated by the container are lazily loaded and initialized only on first use.</p> <p>Provides the following decorators: <code>register</code>, <code>abstract</code> and <code>autowire</code>. Use register on factory functions and concrete classes which are to be injected from the container. Abstract classes are to be used as interfaces and will not be injected directly, rather concrete classes which implement them will be injected instead.</p> <p>Use the <code>autowire</code> decorator on methods where dependency injection must be performed. Services will be injected automatically where possible. Parameters will have to be annotated as they cannot be located from type alone.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-attributes","title":"Attributes","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.context","title":"<code>context: InitializationContext</code>  <code>property</code>","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.override","title":"<code>override: OverrideManager</code>  <code>property</code>","text":"<p>Override registered container services with new values.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.params","title":"<code>params: ParameterBag</code>  <code>property</code>","text":"<p>Parameter bag associated with this container.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-functions","title":"Functions","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.__init__","title":"<code>__init__(parameter_bag)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parameter_bag</code> <code>ParameterBag</code> <p>ParameterBag instance holding parameter information.</p> required"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.abstract","title":"<code>abstract(klass)</code>","text":"<p>Register a type as an interface.</p> <p>This type cannot be initialized directly and one of the components implementing this will be injected instead.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.autowire","title":"<code>autowire(fn)</code>","text":"<p>Automatically inject resources from the container to the decorated methods.</p> <p>Any arguments which the container does not know about will be ignored so that another decorator or framework can supply their values. This decorator can be used on both async and blocking methods.</p> <ul> <li>Classes will be automatically injected.</li> <li>Parameters need to be annotated in order for container to be able to resolve them</li> <li>When injecting an interface for which there are multiple implementations you need to supply a qualifier   using annotations.</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.clear_initialized_objects","title":"<code>clear_initialized_objects()</code>","text":"<p>Drop references to initialized singleton objects.</p> <p>Calling this will cause the container to drop references to initialized singletons and cause it to create new instances when they are requested to be injected.</p> <p>This can be useful in tests in a <code>unittest.TestCase.setUp</code> method or pytest autouse=True fixture, allowing you to have a fresh copy of the container with no previously intitialized instances to make test cases independent of each-other.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.get","title":"<code>get(klass, qualifier=None)</code>","text":"<p>Get an instance of the requested type.</p> <p>Use this to locate services by their type but strongly prefer using injection instead.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>Qualifier for the class if it was registered with one.</p> <code>None</code> <code>klass</code> <code>type[__T]</code> <p>Class of the dependency already registered in the container.</p> required <p>Returns:</p> Type Description <code>__T</code> <p>An instance of the requested object. Always returns an existing instance when one is available.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.is_type_known","title":"<code>is_type_known(klass)</code>","text":"<p>Given a class type return True if's registered in the container as a service or interface.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.register","title":"<code>register(obj=None, *, qualifier=None, lifetime=ServiceLifetime.SINGLETON)</code>","text":"<p>Register a dependency in the container. Dependency must be either a class or a factory function.</p> <ul> <li>Use as a decorator without parameters @container.register on a factory function or class to register it.</li> <li>Use as a decorator with parameters to specify qualifier and lifetime, @container.register(qualifier=...).</li> <li>Call it directly with @container.register(some_class_or_factory, qualifier=..., lifetime=...).</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.warmup","title":"<code>warmup()</code>","text":"<p>Initialize all singleton dependencies registered in the container.</p> <p>This should be executed once all services are registered with the container. Targets of autowire will not be affected.</p>"},{"location":"class/fastapi_integration/","title":"fastapi_integration","text":""},{"location":"class/fastapi_integration/#wireup_init_fastapi_integration","title":"wireup_init_fastapi_integration","text":"<p>Integrate wireup with a fastapi application.</p> <p>This must be called once all views have been registered.  Decorates all views where container objects are being used making  the <code>@container.autowire</code> decorator no longer needed.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The application instance</p> required <code>service_modules</code> <code>list[ModuleType]</code> <p>A list of python modules where application services reside. These will be loaded to trigger container registrations.</p> required <code>dependency_container</code> <code>DependencyContainer</code> <p>The instance of the dependency container. The default wireup singleton will be used when this is unset. This will be a noop and have no performance penalty for views which do not use the container.</p> <code>container</code>"},{"location":"class/flask_integration/","title":"flask_integration","text":""},{"location":"class/flask_integration/#wireup_init_flask_integration","title":"wireup_init_flask_integration","text":"<p>Integrate wireup with a flask application.</p> <p>This must be called once all flask configuration and views have been registered.  Updates the container with flask configuration and decorates all views where container objects  are being used making the <code>@container.autowire</code> decorator no longer needed.</p> <p>Parameters:</p> Name Type Description Default <code>flask_app</code> <code>Flask</code> <p>The flask application instance</p> required <code>service_modules</code> <code>list[ModuleType]</code> <p>A list of python modules where application services reside. These will be loaded to trigger container registrations.</p> required <code>dependency_container</code> <code>DependencyContainer</code> <p>The instance of the dependency container. The default wireup singleton will be used when this is unset. This will be a noop and have no performance penalty for views which do not use the container.</p> <code>container</code> <code>config_prefix</code> <code>str | None</code> <p>If set to a value all registered configuration will be prefixed with config and be accessible via \"prefix.config_name\". E.g: app.DEBUG.</p> <code>None</code>"},{"location":"class/initialization_context/","title":"InitializationContext","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p> <p>Container uses this to determine what to inject for each target.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-attributes","title":"Attributes","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.dependencies","title":"<code>dependencies: Mapping[AutowireTarget, dict[str, AnnotatedParameter]]</code>  <code>property</code>","text":"<p>Read-only view of the dependency definitions.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.lifetime","title":"<code>lifetime: Mapping[type, ServiceLifetime]</code>  <code>property</code>","text":"<p>Read-only view of service lifetime mapping.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-functions","title":"Functions","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.__init__","title":"<code>__init__()</code>","text":"<p>Create a new InitializationContext.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.add_dependency","title":"<code>add_dependency(target, parameter_name, value)</code>","text":"<p>Update the mapping of dependencies for a particular target.</p> <p>Registers a new dependency for the parameter in parameter_name. Target must have been already initialized prior to calling this.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.init_target","title":"<code>init_target(target, lifetime=None)</code>","text":"<p>Initialize the context for a particular target.</p> <p>Returns true on first call. If the target is already registered it returns False.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.remove_dependencies","title":"<code>remove_dependencies(target, names_to_remove)</code>","text":"<p>Remove dependencies with names in <code>names_to_remove</code> from the given target.</p> <p>Target must have been already initialized prior to calling this.</p>"},{"location":"class/override_manager/","title":"OverrideManager","text":"<p>Enables overriding of services registered with the container.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager-functions","title":"Functions","text":""},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.clear","title":"<code>clear()</code>","text":"<p>Clear active service overrides.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.delete","title":"<code>delete(target, qualifier=None)</code>","text":"<p>Clear active override for the <code>target</code> service.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.service","title":"<code>service(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code> for the duration of the context manager.</p> <p>Subsequent autowire calls to <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.services","title":"<code>services(overrides)</code>","text":"<p>Override a number of services with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.set","title":"<code>set(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code>.</p> <p>Subsequent autowire calls to <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values. __param_cache: A dictionary to keep track of which cache entries involve each parameter.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get_all","title":"<code>get_all()</code>","text":"<p>Get all parameters stored in the bag.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing all parameter names and their values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.put","title":"<code>put(name, val)</code>","text":"<p>Put a parameter value into the bag. This overwrites any previous values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter.</p> required <code>val</code> <code>Any</code> <p>The value of the parameter.</p> required"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.update","title":"<code>update(new_params)</code>","text":"<p>Update the bag with new set of parameters.</p> <p>Parameters from new_params will overwrite any existing parameters set with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>new_params</code> <code>dict[str, Any]</code> <p>A dictionary of parameter names and their updated values.</p> required"},{"location":"class/parameter_enum/","title":"ParameterEnum","text":"<p>             Bases: <code>Enum</code></p> <p>Enum with a <code>.wire</code> method allowing easy injection of members.</p> <p>Allows you to add application parameters as enum members and their names as values. When you need to inject a parameter instead of referencing it by name you can annotate the parameter with the wire function call or set that as the default value.</p> <p>This will inject a parameter by name and won't work with expressions.</p>"},{"location":"class/parameter_enum/#wireup.ParameterEnum-functions","title":"Functions","text":""},{"location":"class/parameter_enum/#wireup.ParameterEnum.wire","title":"<code>wire()</code>","text":"<p>Inject the parameter this enumeration member represents.</p> <p>Equivalent of <code>wire(param=EnumParam.enum_member.value)</code></p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup.container","title":"<code>wireup.container = DependencyContainer(ParameterBag())</code>  <code>module-attribute</code>","text":"<p>Singleton DI container instance.</p> <p>Use when your application only needs one container.</p>"},{"location":"class/wireup/#wireup.wire","title":"<code>wireup.wire(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Inject resources from the container to autowired method arguments.</p> <p>Arguments are exclusive and only one of them must be used at any time.</p> <p>Note</p> <p>Methods MUST be still decorated with autowire for this to work.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str | None</code> <p>Inject a given parameter by name.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>Inject a string value using a templated string. Parameters inside <code>${}</code> will be replaced with their corresponding value.</p> <code>None</code> <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>Qualify which implementation to bind when there are multiple components implementing an interface that is registered in the container via <code>@abstract</code>.</p> <code>None</code>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>Dependency injection for FastAPI (all versions) is available via the first-party integration wireup provides, available in <code>wireup.integration.fastapi_integration</code>.</p> <p>Features:</p> <ul> <li>Automatically decorate Flask views and blueprints where the container is being used.<ul> <li>Eliminates the need for <code>@container.autowire</code> in views.</li> <li>Views without container references will not be decorated.</li> <li>Services must be annotated with <code>Wire()</code>.</li> </ul> </li> <li>Can: Mix FastAPI dependencies and Wireup in views</li> <li>Can: Autowire any FastAPI target with <code>@container.autowire</code>.</li> <li>Cannot: Use FastAPI dependencies in Wireup service objects.</li> </ul> <p>Tip</p> <p>As FastAPI does not have a fixed configuration mechanism, you need to expose any configuration objects to the container using one of the two options: </p> <ul> <li>By dumping all values in the parameter bag.</li> <li>By registering the configuration object as a service using a factory function.</li> </ul>"},{"location":"integrations/fastapi/#examples","title":"Examples","text":"<pre><code>app = FastAPI()\n\n@app.get(\"/random\")\nasync def target(\n    # Wire annotation tells wireup that this argument should be injected.\n    random_service: Annotated[RandomService, Wire()],\n    is_debug: Annotated[bool, Wire(param=\"env.debug\")],\n\n    # This is a regular FastAPI dependency.\n    lucky_number: Annotated[int, Depends(get_lucky_number)]\n):\n    return {\n      \"number\": random_service.get_random(), \n      \"lucky_number\": lucky_number,\n      \"is_debug\": is_debug,\n    }\n\n# Initialize the integration.\n# Must be called after all views have been registered.\n# Pass to service_modules a list of top-level modules where your services reside.\nwireup_init_fastapi_integration(app, service_modules=[services])\n</code></pre>"},{"location":"integrations/fastapi/#api-reference","title":"Api Reference","text":"<ul> <li>fastapi_integration</li> </ul>"},{"location":"integrations/flask/","title":"Flask","text":"<p>Dependency injection for Flask (all versions) is available via the first-party integration wireup provides, available in <code>wireup.integration.flask_integration</code>.</p> <p>Features:</p> <ul> <li>Automatically decorate Flask views and blueprints where the container is being used.<ul> <li>Eliminates the need for <code>@container.autowire</code> in views.</li> <li>Views without container references will not be decorated.</li> </ul> </li> <li>Expose Flask configuration in the container's parameters.</li> </ul>"},{"location":"integrations/flask/#examples","title":"Examples","text":"<pre><code>app = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\n@app.get(\"/random\")\ndef get_random(random: RandomService):\n    return {\"lucky_number\": random.get_random()}\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Wire(param=\"DEBUG\")], \n    foo: Annotated[str, Wire(param=\"FOO\")]\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n\n\nif __name__ == '__main__':\n    # Initialize the integration.\n    # Must be called after all views and configuration have been added.\n    # Pass to service_modules a list of top-level modules where your services reside.\n    wireup_init_flask_integration(app, service_modules=[services])\n    app.run()\n</code></pre>"},{"location":"integrations/flask/#using-parameter-enums","title":"Using parameter enums","text":"<p>Parameter enums offer a typed way of representing parameters.  See Parameter Enum documentation for more details</p>"},{"location":"integrations/flask/#api-reference","title":"Api Reference","text":"<ul> <li>flask_integration</li> <li>ParameterEnum</li> </ul>"}]}